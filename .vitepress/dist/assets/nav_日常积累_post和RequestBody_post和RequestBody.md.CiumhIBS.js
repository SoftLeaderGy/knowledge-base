import{_ as e,c as a,o as t,a4 as s}from"./chunks/framework.IpiIUH1b.js";const o="/assets/1667551045042-0f9d7384-52d1-4cfa-aca7-eb71833d6f4d.C5SORo_D.png",i="/assets/1667552088145-119b725a-55dd-4c52-a33e-45031345f654.BxnlrtBC.png",l="/assets/1667552427087-b500abd3-7587-4b1d-9a76-e380a60e5e6b.BMpWMJ9w.png",c="/assets/1667552462029-90261615-8999-4512-8ea1-481d96202a0f.CmYPguTc.png",n="/assets/1667552541717-1d9564f7-e8ee-4ec6-88e4-efb38325b6d8.BlhmUNMc.png",d="/assets/1667552565525-8ae3f234-e8e0-4ea1-a731-9509cbfdbefb.CA8Um5Dj.png",p="/assets/1667552890193-37cc2726-0492-487c-b333-624acd145473.DIi7ukxG.png",r="/assets/1667552905821-086c5e44-e99a-41ea-bd52-7567ad49c52d.DZwdsHRP.png",u="/assets/1667553017443-ec5fe40c-61bc-439b-8d4f-c010a5801edc.ZCpyhzdw.png",_="/assets/1667553038621-de787bad-31ae-4ee9-b976-c97ec28ee21b.BYhaLXJ8.png",x=JSON.parse('{"title":"一、发现问题","description":"","frontmatter":{},"headers":[],"relativePath":"nav/日常积累/post和RequestBody/post和RequestBody.md","filePath":"nav/日常积累/post和RequestBody/post和RequestBody.md","lastUpdated":null}'),m={name:"nav/日常积累/post和RequestBody/post和RequestBody.md"},g=s('<ul><li>今天在公司偶然发现一个很神奇的代码。上截图</li></ul><p><img src="'+o+'" alt="image.png"></p><h1 id="一、发现问题" tabindex="-1">一、发现问题 <a class="header-anchor" href="#一、发现问题" aria-label="Permalink to &quot;一、发现问题&quot;">​</a></h1><blockquote><p>一个post请求并没有请求体，只是把参数拼在了路径的后边，后台接口接收的参数上也并没有加<code>@RequestBody</code>，接收的参数同样是实体类。<br>神奇的是接口接收到了参数。</p></blockquote><h1 id="二、查资料" tabindex="-1">二、查资料 <a class="header-anchor" href="#二、查资料" aria-label="Permalink to &quot;二、查资料&quot;">​</a></h1><p>求知聊天记录<img src="'+i+'" alt="image.png"></p><h1 id="三、探究" tabindex="-1">三、探究 <a class="header-anchor" href="#三、探究" aria-label="Permalink to &quot;三、探究&quot;">​</a></h1><ul><li>我们都知道post请求在请求体的情况下，接口不加<code>@RequestBody</code>传入的请求体参数是不能被接收的 <ul><li><img src="'+l+'" alt="image.png"></li><li><img src="'+c+'" alt="image.png"></li></ul></li><li>我们把参数拼在后边，并且请求体也传入参数的话 <ul><li><img src="'+n+'" alt="image.png"></li><li><img src="'+d+'" alt="image.png"></li><li>到此我们得出结论：接口在不加<code>@RequestBody</code>注解的时候，我们传入请求体与否对于接口来说是无效的，只有我们拼了参数在后边才会接受到参数</li></ul></li><li>接口添加<code>@RequestBody</code> 注解 拼接参数且不传入请求体 <ul><li><img src="'+p+'" alt="image.png"></li><li><img src="'+r+'" alt="image.png"></li><li>此时我们的服务端返回报错400</li><li>报错信息为：Required request body is missing:........</li></ul></li><li>接口添加<code>@RequestBody</code> 注解 拼接参数且传入请求体 <ul><li><img src="'+u+'" alt="image.png"></li><li><img src="'+_+'" alt="image.png"></li><li>此时我们的接口一样可以接收到参数</li></ul></li></ul><h1 id="四、结论" tabindex="-1">四、结论 <a class="header-anchor" href="#四、结论" aria-label="Permalink to &quot;四、结论&quot;">​</a></h1><blockquote><p>@RequestBody 主要用于处理 json格式数据，Content-type:application/json ContentType类型application/x-www-form-urlencoded,格式为key1=value1&amp;key2=value2提交到后台 ，不需要加@requestBody。 <code>使用@requestBody.当请求content_type为：application/json类型的请求，数据类型为json时， json格式如下：{“aaa”:“111”,“bbb”:“222”}</code></p></blockquote><p>建议在项目当中不要使用文章开头的形式去写，第一会引起歧义，前台不好写，后台也蒙，最好严格按照 GET（拼接）POST（请求体）的形式，清晰明了</p><hr><p>END.....</p>',13),b=[g];function h(q,f,y,B,R,k){return t(),a("div",null,b)}const T=e(m,[["render",h]]);export{x as __pageData,T as default};
